-- Pook Animation Editor v0.7 - Exportação Manual (Studio Lite, executor friendly)
if game.CoreGui:FindFirstChild("PookAnimEditor") then
    game.CoreGui.PookAnimEditor:Destroy()
end
if game.CoreGui:FindFirstChild("PookExportGui") then
    game.CoreGui.PookExportGui:Destroy()
end

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")
local UserInputService = game:GetService("UserInputService")
local Workspace = workspace

local VERSION = "Pook Animation Editor v0.7"
local DEFAULT_FPS = 30
local DEFAULT_TIMELINE_LENGTH = 100
local PIXELS_PER_FRAME = 5
local mainW, mainH = 700, 400

local gui = Instance.new("ScreenGui")
gui.Name = "PookAnimEditor"
gui.Parent = game.CoreGui
gui.ResetOnSpawn = false

-- Função para exportação manual por GUI
function exportAnimToGui(moduleCode)
    if game.CoreGui:FindFirstChild("PookExportGui") then
        game.CoreGui.PookExportGui:Destroy()
    end
    local gui2 = Instance.new("ScreenGui")
    gui2.Name = "PookExportGui"
    gui2.Parent = game.CoreGui
    gui2.ResetOnSpawn = false

    local main = Instance.new("Frame")
    main.Size = UDim2.fromOffset(540, 340)
    main.Position = UDim2.new(0.5, -270, 0.5, -170)
    main.BackgroundColor3 = Color3.fromRGB(30,32,38)
    main.BorderSizePixel = 0
    main.Parent = gui2
    main.Active = true
    main.Draggable = true

    local titleBar = Instance.new("Frame")
    titleBar.Name = "TitleBar"
    titleBar.Size = UDim2.new(1,0,0,34)
    titleBar.Position = UDim2.new(0,0,0,0)
    titleBar.BackgroundColor3 = Color3.fromRGB(18,20,26)
    titleBar.BorderSizePixel = 0
    titleBar.Parent = main
    titleBar.Active = true
    titleBar.Draggable = true

    local title = Instance.new("TextLabel")
    title.Text = "Exportar Código Lua (ModuleScript)"
    title.BackgroundTransparency = 1
    title.TextColor3 = Color3.fromRGB(230,230,250)
    title.Font = Enum.Font.SourceSansBold
    title.TextSize = 17
    title.Size = UDim2.new(1, -38, 1, 0)
    title.Position = UDim2.new(0,12,0,0)
    title.TextXAlignment = Enum.TextXAlignment.Left
    title.Parent = titleBar

    local closeBtn = Instance.new("TextButton")
    closeBtn.Text = "✕"
    closeBtn.Size = UDim2.fromOffset(32, 24)
    closeBtn.Position = UDim2.new(1, -36, 0, 5)
    closeBtn.BackgroundColor3 = Color3.fromRGB(48,48,52)
    closeBtn.TextColor3 = Color3.fromRGB(220,90,90)
    closeBtn.Font = Enum.Font.SourceSansBold
    closeBtn.TextSize = 18
    closeBtn.Parent = titleBar
    closeBtn.MouseButton1Click:Connect(function()
        gui2:Destroy()
    end)

    local scriptBox = Instance.new("TextBox")
    scriptBox.Size = UDim2.new(1, -40, 1, -70)
    scriptBox.Position = UDim2.new(0, 20, 0, 40)
    scriptBox.Text = moduleCode
    scriptBox.Font = Enum.Font.Code
    scriptBox.TextSize = 15
    scriptBox.TextColor3 = Color3.fromRGB(220,220,220)
    scriptBox.BackgroundColor3 = Color3.fromRGB(44,46,58)
    scriptBox.ClearTextOnFocus = false
    scriptBox.MultiLine = true
    scriptBox.TextWrapped = false
    scriptBox.TextXAlignment = Enum.TextXAlignment.Left
    scriptBox.TextYAlignment = Enum.TextYAlignment.Top
    scriptBox.Parent = main

    local hint = Instance.new("TextLabel")
    hint.Text = "Selecione tudo (Ctrl+A), copie (Ctrl+C) e cole em um ModuleScript!"
    hint.Size = UDim2.new(1, -20, 0, 24)
    hint.Position = UDim2.new(0, 10, 1, -28)
    hint.BackgroundTransparency = 1
    hint.TextColor3 = Color3.fromRGB(170,220,140)
    hint.Font = Enum.Font.SourceSans
    hint.TextSize = 14
    hint.TextXAlignment = Enum.TextXAlignment.Left
    hint.TextYAlignment = Enum.TextYAlignment.Top
    hint.Parent = main
end

local function new(class, props)
    local o = Instance.new(class)
    for k, v in pairs(props) do o[k] = v end
    return o
end

local function makeDraggable(frame, handle)
    handle = handle or frame
    local dragging, dragStart, startPos = false
    handle.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            dragStart = input.Position
            startPos = frame.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)
    UserInputService.InputChanged:Connect(function(input)
        if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
            local delta = input.Position - dragStart
            frame.Position = UDim2.new(
                startPos.X.Scale, startPos.X.Offset + delta.X,
                startPos.Y.Scale, startPos.Y.Offset + delta.Y
            )
        end
    end)
end

-- MAIN WINDOW
local main = new("Frame", {
    Size=UDim2.fromOffset(mainW, mainH),
    Position=UDim2.new(0.5, -mainW/2, 0.5, -mainH/2),
    BackgroundColor3=Color3.fromRGB(28,30,38),
    BorderSizePixel=0,
    Parent=gui,
    Name="MainFrame",
    Active=true
})
makeDraggable(main, main)

-- TITLEBAR
local titleBar = new("Frame", {
    Size=UDim2.new(1,0,0,32),
    BackgroundColor3=Color3.fromRGB(18,20,26),
    Parent=main,
    Name="TitleBar"
})
makeDraggable(main, titleBar)
local title = new("TextLabel", {
    Size=UDim2.new(1,-120,1,0),
    Position=UDim2.new(0,12,0,0),
    BackgroundTransparency=1,
    Text=VERSION,
    Font=Enum.Font.SourceSansBold,
    TextSize=16,
    TextColor3=Color3.fromRGB(230,230,250),
    TextXAlignment=Enum.TextXAlignment.Left,
    Parent=titleBar
})
local closeBtn = new("TextButton", {
    Size=UDim2.fromOffset(32,24),
    Position=UDim2.new(1,-36,0,4),
    BackgroundColor3=Color3.fromRGB(50,50,56),
    Text="✕",
    Font=Enum.Font.SourceSansBold,
    TextSize=18,
    TextColor3=Color3.fromRGB(230,100,100),
    Parent=titleBar
})
closeBtn.MouseButton1Click:Connect(function() gui:Destroy() end)

-- SLOTS SYSTEM
local savedSlots = {}
for i=1,5 do
    savedSlots[i] = {name="Slot "..i, data=nil}
end

local slotBtn = Instance.new("TextButton")
slotBtn.Name = "SlotBtn"
slotBtn.Text = "Slots"
slotBtn.Size = UDim2.fromOffset(56, 24)
slotBtn.Position = UDim2.new(1, -100, 0, 4)
slotBtn.BackgroundColor3 = Color3.fromRGB(70,70,120)
slotBtn.TextColor3 = Color3.fromRGB(255,255,255)
slotBtn.Font = Enum.Font.SourceSansBold
slotBtn.TextSize = 15
slotBtn.Parent = titleBar

local slotGui = Instance.new("Frame")
slotGui.Name = "SlotGui"
slotGui.Size = UDim2.fromOffset(340, 260)
slotGui.Position = UDim2.new(0.5, -170, 0.5, -130)
slotGui.BackgroundColor3 = Color3.fromRGB(30,32,38)
slotGui.BorderSizePixel = 0
slotGui.Visible = false
slotGui.Parent = gui
slotGui.Active = true
slotGui.Draggable = true

local slotTitle = Instance.new("TextLabel", slotGui)
slotTitle.Text = "Slots de Animação"
slotTitle.Size = UDim2.new(1, -38, 0, 28)
slotTitle.Position = UDim2.new(0, 12, 0, 4)
slotTitle.BackgroundTransparency = 1
slotTitle.TextColor3 = Color3.fromRGB(230,230,250)
slotTitle.Font = Enum.Font.SourceSansBold
slotTitle.TextSize = 18
slotTitle.TextXAlignment = Enum.TextXAlignment.Left

local slotClose = Instance.new("TextButton", slotGui)
slotClose.Text = "✕"
slotClose.Size = UDim2.fromOffset(32, 24)
slotClose.Position = UDim2.new(1, -36, 0, 6)
slotClose.BackgroundColor3 = Color3.fromRGB(48,48,52)
slotClose.TextColor3 = Color3.fromRGB(220,90,90)
slotClose.Font = Enum.Font.SourceSansBold
slotClose.TextSize = 18
slotClose.MouseButton1Click:Connect(function() slotGui.Visible = false end)

local function cloneTable(t)
    local out = {}
    for k,v in pairs(t) do
        if type(v) == "table" then
            out[k] = cloneTable(v)
        else
            out[k] = v
        end
    end
    return out
end

local function refreshSlots()
    for _,v in pairs(slotGui:GetChildren()) do
        if v:IsA("Frame") and v.Name:match("^Slot") then v:Destroy() end
    end
    for i=1,5 do
        local f = Instance.new("Frame")
        f.Name = "SlotFrame"..i
        f.Parent = slotGui
        f.Size = UDim2.new(1,-24,0,38)
        f.Position = UDim2.new(0,12,0,36 + (i-1)*42)
        f.BackgroundColor3 = Color3.fromRGB(36,38,45)
        local tb = Instance.new("TextBox", f)
        tb.Text = savedSlots[i].name
        tb.Size = UDim2.new(0.34,0,1,0)
        tb.Position = UDim2.new(0,8,0,0)
        tb.Font = Enum.Font.SourceSans
        tb.TextSize = 15
        tb.TextColor3 = Color3.fromRGB(230,230,220)
        tb.BackgroundColor3 = Color3.fromRGB(45,45,50)
        tb.ClearTextOnFocus = false
        tb.FocusLost:Connect(function()
            savedSlots[i].name = tb.Text
        end)
        local btnSave = Instance.new("TextButton", f)
        btnSave.Text = "Salvar"
        btnSave.Size = UDim2.new(0,60,1,0)
        btnSave.Position = UDim2.new(0.39,10,0,0)
        btnSave.Font = Enum.Font.SourceSansBold
        btnSave.TextSize = 15
        btnSave.BackgroundColor3 = Color3.fromRGB(40,140,60)
        btnSave.TextColor3 = Color3.fromRGB(255,255,255)
        btnSave.MouseButton1Click:Connect(function()
            savedSlots[i].data = {
                fps = Editor.fps,
                timelineLength = Editor.timelineLength,
                frames = cloneTable(Editor.frames)
            }
            btnSave.Text = "Salvo!"
            wait(0.8)
            btnSave.Text = "Salvar"
        end)
        local btnLoad = Instance.new("TextButton", f)
        btnLoad.Text = "Carregar"
        btnLoad.Size = UDim2.new(0,72,1,0)
        btnLoad.Position = UDim2.new(0.61,12,0,0)
        btnLoad.Font = Enum.Font.SourceSansBold
        btnLoad.TextSize = 15
        btnLoad.BackgroundColor3 = Color3.fromRGB(80,110,185)
        btnLoad.TextColor3 = Color3.fromRGB(255,255,255)
        btnLoad.MouseButton1Click:Connect(function()
            if savedSlots[i].data then
                Editor.fps = savedSlots[i].data.fps or DEFAULT_FPS
                Editor.timelineLength = savedSlots[i].data.timelineLength or DEFAULT_TIMELINE_LENGTH
                Editor.frames = cloneTable(savedSlots[i].data.frames or {})
                renderKeyframesUI()
                btnLoad.Text = "Carregado!"
                wait(0.8)
                btnLoad.Text = "Carregar"
            else
                btnLoad.Text = "Vazio!"
                wait(0.8)
                btnLoad.Text = "Carregar"
            end
        end)
        local lbl = Instance.new("TextLabel", f)
        lbl.Text = savedSlots[i].data and "Anim salva" or ""
        lbl.Size = UDim2.new(0,80,1,0)
        lbl.Position = UDim2.new(1,-80,0,0)
        lbl.BackgroundTransparency = 1
        lbl.Font = Enum.Font.SourceSans
        lbl.TextSize = 13
        lbl.TextColor3 = Color3.fromRGB(140,240,160)
        lbl.TextXAlignment = Enum.TextXAlignment.Right
    end
end
slotBtn.MouseButton1Click:Connect(function()
    slotGui.Visible = true
    refreshSlots()
end)

-- PAINÉIS RESTANTES
local rightPanel = new("Frame", {
    Name="RightPanel",
    Size=UDim2.fromOffset(160, mainH-32),
    Position=UDim2.new(1,-160,0,32),
    BackgroundColor3=Color3.fromRGB(36,38,45),
    Parent=main
})
local rightTitle = new("TextLabel", {
    Parent=rightPanel,
    Size=UDim2.new(1,0,0,22),
    BackgroundTransparency=1,
    Text="Export/Import",
    Font=Enum.Font.SourceSansBold,
    TextSize=13,
    TextColor3=Color3.fromRGB(220,220,220),
    TextXAlignment=Enum.TextXAlignment.Left,
    Position=UDim2.new(0,8,0,4)
})
local btnExportJSON = new("TextButton", {
    Parent=rightPanel,
    Size=UDim2.fromOffset(120,24),
    Position=UDim2.new(0,16,1,-88),
    Text="Exportar JSON",
    Font=Enum.Font.SourceSansBold,
    TextSize=13,
    BackgroundColor3=Color3.fromRGB(40,140,60),
    TextColor3=Color3.fromRGB(255,255,255)
})
local btnExportScript = new("TextButton", {
    Parent=rightPanel,
    Size=UDim2.fromOffset(120,24),
    Position=UDim2.new(0,16,1,-60),
    Text="Exportar Script",
    Font=Enum.Font.SourceSansBold,
    TextSize=13,
    BackgroundColor3=Color3.fromRGB(220,180,60),
    TextColor3=Color3.fromRGB(40,40,40)
})
local btnImport = new("TextButton", {
    Parent=rightPanel,
    Size=UDim2.fromOffset(120,24),
    Position=UDim2.new(0,16,1,-32),
    Text="Importar JSON",
    Font=Enum.Font.SourceSansBold,
    TextSize=13,
    BackgroundColor3=Color3.fromRGB(80,110,185),
    TextColor3=Color3.fromRGB(240,240,255)
})
local importBox = new("TextBox", {
    Parent=rightPanel,
    Size=UDim2.new(1,-30,0,24),
    Position=UDim2.new(0,14,1,-118),
    PlaceholderText="Cole o JSON aqui",
    Font=Enum.Font.Code,
    BackgroundColor3=Color3.fromRGB(44,44,48),
    TextColor3=Color3.fromRGB(200,230,200),
    TextSize=12,
    ClearTextOnFocus=false
})

-- TIMELINE + PREVIEW
local centerPanel = new("Frame", {
    Size=UDim2.fromOffset(mainW-120-160, mainH-32-44),
    Position=UDim2.new(0,120,0,32),
    BackgroundColor3=Color3.fromRGB(26,28,38),
    Parent=main,
    Name="CenterPanel"
})
local viewport = new("Frame", {
    Name="Viewport",
    Size=UDim2.new(1,0,1,-70),
    BackgroundColor3=Color3.fromRGB(18,18,18),
    Parent=centerPanel
})
local timelinePanel = new("Frame", {
    Name="TimelinePanel",
    Size=UDim2.new(1,0,0,70),
    Position=UDim2.new(0,0,1,-70),
    BackgroundColor3=Color3.fromRGB(20,20,24),
    Parent=centerPanel
})
local timelineBar = new("Frame", {
    Parent=timelinePanel,
    Name="TimelineBar",
    Size=UDim2.new(1,-10,0,22),
    Position=UDim2.new(0,5,0,8),
    BackgroundColor3=Color3.fromRGB(36,36,40)
})
local playhead = new("Frame", {
    Name="Playhead",
    Size=UDim2.fromOffset(2, 22),
    BackgroundColor3=Color3.fromRGB(255,80,80),
    Position=UDim2.new(0,0,0,0),
    Parent=timelineBar,
    ZIndex=5
})

-- CONTROLS
local controls = new("Frame", {
    Parent=timelinePanel,
    Size=UDim2.new(1,-10,0,32),
    Position=UDim2.new(0,5,1,-36),
    BackgroundTransparency=1
})
local btnPlay = new("TextButton", {
    Parent=controls,
    Size=UDim2.fromOffset(50,22),
    Position=UDim2.new(1,-54,0,5),
    Text="Play",
    Font=Enum.Font.SourceSans,
    TextSize=13
})
local btnStop = new("TextButton", {
    Parent=controls,
    Size=UDim2.fromOffset(50,22),
    Position=UDim2.new(1,-112,0,5),
    Text="Stop",
    Font=Enum.Font.SourceSans,
    TextSize=13
})
local btnAddKF = new("TextButton", {
    Parent=controls,
    Size=UDim2.fromOffset(90,22),
    Position=UDim2.new(0,8,0,5),
    Text="Add KF (K)",
    Font=Enum.Font.SourceSans,
    TextSize=13
})
local btnDeleteKF = new("TextButton", {
    Parent=controls,
    Size=UDim2.fromOffset(90,22),
    Position=UDim2.new(0,108,0,5),
    Text="Del KF (L)",
    Font=Enum.Font.SourceSans,
    TextSize=13
})
local lblFrame = new("TextLabel", {
    Parent=controls,
    Size=UDim2.fromOffset(100,22),
    Position=UDim2.new(0,210,0,5),
    Text="Frame: 0",
    BackgroundTransparency=1,
    TextColor3=Color3.fromRGB(220,220,220),
    TextSize=13,
    Font=Enum.Font.SourceSans,
    TextXAlignment=Enum.TextXAlignment.Left
})

-- ESTADO DO EDITOR
local Editor = {
    rig = nil,
    skeleton = {},
    preview = nil,
    frames = {},
    currentTime = 0,
    playing = false,
    fps = DEFAULT_FPS,
    timelineLength = DEFAULT_TIMELINE_LENGTH,
    selectedKeyframe = nil
}

-- Utils
local function cframeToTable(cf)
    local a,b,c,d,e,f,g,h,i,j,k,l = cf:components()
    return {a,b,c,d,e,f,g,h,i,j,k,l}
end
local function tableToCFrame(tbl)
    return CFrame.new(unpack(tbl))
end

local function clearHierarchy()
    for _,v in pairs(hierarchyList:GetChildren()) do
        if v:IsA("TextButton") or v:IsA("TextLabel") then v:Destroy() end
    end
end
local function buildHierarchy()
    clearHierarchy()
    for i,part in ipairs(Editor.skeleton) do
        local btn = new("TextButton", {
            Parent=hierarchyList,
            Size=UDim2.new(1, -8, 0, 18),
            BackgroundColor3=Color3.fromRGB(44,44,46),
            TextColor3=Color3.fromRGB(230,230,230),
            Font=Enum.Font.SourceSans,
            TextSize=12,
            Text=part.Name
        })
    end
end
local function buildPreviewClone(dummy)
    if Editor.preview and Editor.preview.Parent then
        Editor.preview:Destroy()
        Editor.preview = nil
    end
    if not dummy then return end
    local clone = dummy:Clone()
    clone.Name = "PreviewDummy"
    for _,d in pairs(clone:GetDescendants()) do
        if d:IsA("Script") or d:IsA("LocalScript") then d:Destroy() end
    end
    clone.Parent = viewport
    Editor.preview = clone
end

local function evaluateAtFrameFloat(frameFloat)
    if frameFloat < 0 then frameFloat = 0 end
    local keys = {}
    for k,_ in pairs(Editor.frames) do table.insert(keys,k) end
    table.sort(keys)
    if #keys==0 then return nil end
    local left,right
    for i,k in ipairs(keys) do
        if k <= frameFloat then left = k end
        if k > frameFloat then right = k; break end
    end
    if not left then left = keys[1] end
    if not right then right = keys[#keys] end
    if left==right or frameFloat==left then
        return Editor.frames[left]
    end
    local t = (frameFloat-left)/(right-left)
    local leftData = Editor.frames[left] or {}
    local rightData = Editor.frames[right] or {}
    local result = {}
    local seen = {}
    for partName,ldata in pairs(leftData) do
        local rdata = rightData[partName] or ldata
        local ca = tableToCFrame(ldata.CFrame)
        local cb = tableToCFrame(rdata.CFrame)
        local lerp = ca:Lerp(cb, t)
        result[partName] = { CFrame = cframeToTable(lerp) }
        seen[partName] = true
    end
    for partName,rdata in pairs(rightData) do
        if not seen[partName] then
            result[partName] = { CFrame = rdata.CFrame }
        end
    end
    return result
end

local function applyFrameToModel(model, frameData)
    if not model or not frameData then return end
    local root = model.PrimaryPart or model:FindFirstChildWhichIsA("BasePart")
    if root then
        local rootC = root.CFrame
        for partName, data in pairs(frameData) do
            local p = model:FindFirstChild(partName, true)
            if p and p:IsA("BasePart") then
                local rel = tableToCFrame(data.CFrame)
                p.CFrame = rootC * rel
            end
        end
    else
        for partName, data in pairs(frameData) do
            local p = model:FindFirstChild(partName, true)
            if p and p:IsA("BasePart") then
                p.CFrame = tableToCFrame(data.CFrame)
            end
        end
    end
end

local function renderKeyframesUI()
    for _,ch in pairs(timelineBar:GetChildren()) do
        if ch:IsA("ImageButton") or (ch:IsA("Frame") and ch.Name:sub(1,3)=="KF_") then ch:Destroy() end
    end
    for frameIndex,_ in pairs(Editor.frames) do
        local x = frameIndex * PIXELS_PER_FRAME
        local marker = new("ImageButton", {
            Parent=timelineBar,
            Name="KF_"..tostring(frameIndex),
            Size=UDim2.fromOffset(8,18),
            Position=UDim2.new(0,x,0,2),
            BackgroundTransparency=1,
            AutoButtonColor=true
        })
        marker.MouseButton1Click:Connect(function()
            Editor.selectedKeyframe = frameIndex
            Editor.currentTime = frameIndex / Editor.fps
            updatePlayheadVisual()
            updatePreviewFromTime()
        end)
    end
end

local function updatePlayheadVisual()
    local frameFloat = Editor.currentTime * Editor.fps
    local x = frameFloat * PIXELS_PER_FRAME
    playhead.Position = UDim2.new(0, x, 0, 0)
    lblFrame.Text = ("Frame: %.1f"):format(frameFloat)
end

local function updatePreviewFromTime()
    local frameFloat = Editor.currentTime * Editor.fps
    local evaluated = evaluateAtFrameFloat(frameFloat)
    if evaluated and Editor.preview then
        applyFrameToModel(Editor.preview, evaluated)
    end
end

local playConnection
local function startPlay()
    if Editor.playing then return end
    Editor.playing = true
    local playStart = tick()
    local playStartFrame = Editor.rt",
    Size=UDim2.new(1,0,1,-70),
    BackgroundColor3=Color3.fromRGB(18,18,18),
    Parent=centerPanel
})
local timelinePanel = new("Frame", {
    Name="TimelinePanel",
    Size=UDim2.new(1,0,0,70),
    Position=UDim2.new(0,0,1,-70),
    BackgroundColor3=Color3.fromRGB(20,20,24),
    Parent=centerPanel
})
local timelineBar = new("Frame", {
    Parent=timelinePanel,
    Name="TimelineBar",
    Size=UDim2.new(1,-10,0,22),
    Position=UDim2.new(0,5,0,8),
    BackgroundColor3=Color3.fromRGB(36,36,40)
})
local playhead = new("Frame", {
    Name="Playhead",
    Size=UDim2.fromOffset(2, 22),
    BackgroundColor3=Color3.fromRGB(255,80,80),
    Position=UDim2.new(0,0,0,0),
    Parent=timelineBar,
    ZIndex=5
})

-- CONTROLS
local controls = new("Frame", {
    Parent=timelinePanel,
    Size=UDim2.new(1,-10,0,32),
    Position=UDim2.new(0,5,1,-36),
    BackgroundTransparency=1
})
local btnPlay = new("TextButton", {
    Parent=controls,
    Size=UDim2.fromOffset(50,22),
    Position=UDim2.new(1,-54,0,5),
    Text="Play",
    Font=Enum.Font.SourceSans,
    TextSize=13
})
local btnStop = new("TextButton", {
    Parent=controls,
    Size=UDim2.fromOffset(50,22),
    Position=UDim2.new(1,-112,0,5),
    Text="Stop",
    Font=Enum.Font.SourceSans,
    TextSize=13
})
local btnAddKF = new("TextButton", {
    Parent=controls,
    Size=UDim2.fromOffset(90,22),
    Position=UDim2.new(0,8,0,5),
    Text="Add KF (K)",
    Font=Enum.Font.SourceSans,
    TextSize=13
})
local btnDeleteKF = new("TextButton", {
    Parent=controls,
    Size=UDim2.fromOffset(90,22),
    Position=UDim2.new(0,108,0,5),
    Text="Del KF (L)",
    Font=Enum.Font.SourceSans,
    TextSize=13
})
local lblFrame = new("TextLabel", {
    Parent=controls,
    Size=UDim2.fromOffset(100,22),
    Position=UDim2.new(0,210,0,5),
    Text="Frame: 0",
    BackgroundTransparency=1,
    TextColor3=Color3.fromRGB(220,220,220),
    TextSize=13,
    Font=Enum.Font.SourceSans,
    TextXAlignment=Enum.TextXAlignment.Left
})

-- ESTADO DO EDITOR
local Editor = {
    rig = nil,
    skeleton = {},
    preview = nil,
    frames = {},
    currentTime = 0,
    playing = false,
    fps = DEFAULT_FPS,
    timelineLength = DEFAULT_TIMELINE_LENGTH,
    selectedKeyframe = nil
}

-- Utils
local function cframeToTable(cf)
    local a,b,c,d,e,f,g,h,i,j,k,l = cf:components()
    return {a,b,c,d,e,f,g,h,i,j,k,l}
end
local function tableToCFrame(tbl)
    return CFrame.new(unpack(tbl))
end

local function clearHierarchy()
    for _,v in pairs(hierarchyList:GetChildren()) do
        if v:IsA("TextButton") or v:IsA("TextLabel") then v:Destroy() end
    end
end
local function buildHierarchy()
    clearHierarchy()
    for i,part in ipairs(Editor.skeleton) do
        local btn = new("TextButton", {
            Parent=hierarchyList,
            Size=UDim2.new(1, -8, 0, 18),
            BackgroundColor3=Color3.fromRGB(44,44,46),
            TextColor3=Color3.fromRGB(230,230,230),
            Font=Enum.Font.SourceSans,
            TextSize=12,
            Text=part.Name
        })
    end
end
local function buildPreviewClone(dummy)
    if Editor.preview and Editor.preview.Parent then
        Editor.preview:Destroy()
        Editor.preview = nil
    end
    if not dummy then return end
    local clone = dummy:Clone()
    clone.Name = "PreviewDummy"
    for _,d in pairs(clone:GetDescendants()) do
        if d:IsA("Script") or d:IsA("LocalScript") then d:Destroy() end
    end
    clone.Parent = viewport
    Editor.preview = clone
end

local function evaluateAtFrameFloat(frameFloat)
    if frameFloat < 0 then frameFloat = 0 end
    local keys = {}
    for k,_ in pairs(Editor.frames) do table.insert(keys,k) end
    table.sort(keys)
    if #keys==0 then return nil end
    local left,right
    for i,k in ipairs(keys) do
        if k <= frameFloat then left = k end
        if k > frameFloat then right = k; break end
    end
    if not left then left = keys[1] end
    if not right then right = keys[#keys] end
    if left==right or frameFloat==left then
        return Editor.frames[left]
    end
    local t = (frameFloat-left)/(right-left)
    local leftData = Editor.frames[left] or {}
    local rightData = Editor.frames[right] or {}
    local result = {}
    local seen = {}
    for partName,ldata in pairs(leftData) do
        local rdata = rightData[partName] or ldata
        local ca = tableToCFrame(ldata.CFrame)
        local cb = tableToCFrame(rdata.CFrame)
        local lerp = ca:Lerp(cb, t)
        result[partName] = { CFrame = cframeToTable(lerp) }
        seen[partName] = true
    end
    for partName,rdata in pairs(rightData) do
        if not seen[partName] then
            result[partName] = { CFrame = rdata.CFrame }
        end
    end
    return result
end

local function applyFrameToModel(model, frameData)
    if not model or not frameData then return end
    local root = model.PrimaryPart or model:FindFirstChildWhichIsA("BasePart")
    if root then
        local rootC = root.CFrame
        for partName, data in pairs(frameData) do
            local p = model:FindFirstChild(partName, true)
            if p and p:IsA("BasePart") then
                local rel = tableToCFrame(data.CFrame)
                p.CFrame = rootC * rel
            end
        end
    else
        for partName, data in pairs(frameData) do
            local p = model:FindFirstChild(partName, true)
            if p and p:IsA("BasePart") then
                p.CFrame = tableToCFrame(data.CFrame)
            end
        end
    end
end

local function renderKeyframesUI()
    for _,ch in pairs(timelineBar:GetChildren()) do
        if ch:IsA("ImageButton") or (ch:IsA("Frame") and ch.Name:sub(1,3)=="KF_") then ch:Destroy() end
    end
    for frameIndex,_ in pairs(Editor.frames) do
        local x = frameIndex * PIXELS_PER_FRAME
        local marker = new("ImageButton", {
            Parent=timelineBar,
            Name="KF_"..tostring(frameIndex),
            Size=UDim2.fromOffset(8,18),
            Position=UDim2.new(0,x,0,2),
            BackgroundTransparency=1,
            AutoButtonColor=true
        })
        marker.MouseButton1Click:Connect(function()
            Editor.selectedKeyframe = frameIndex
            Editor.currentTime = frameIndex / Editor.fps
            updatePlayheadVisual()
            updatePreviewFromTime()
        end)
    end
end

local function updatePlayheadVisual()
    local frameFloat = Editor.currentTime * Editor.fps
    local x = frameFloat * PIXELS_PER_FRAME
    playhead.Position = UDim2.new(0, x, 0, 0)
    lblFrame.Text = ("Frame: %.1f"):format(frameFloat)
end

local function updatePreviewFromTime()
    local frameFloat = Editor.currentTime * Editor.fps
    local evaluated = evaluateAtFrameFloat(frameFloat)
    if evaluated and Editor.preview then
        applyFrameToModel(Editor.preview, evaluated)
    end
end

local playConnection
local function startPlay()
    if Editor.playing then return end
    Editor.playing = true
    local playStart = tick()
    local playStartFrame = Editor.currentTime * Editor.fps
    playConnection = RunService.RenderStepped:Connect(function()
        local elapsed = tick()-playStart
        local frame = playStartFrame+elapsed*Editor.fps
        if frame > Editor.timelineLength then
            frame = frame % Editor.timelineLength
            playStart = tick()
            playStartFrame = frame
        end
        Editor.currentTime = frame/Editor.fps
        updatePlayheadVisual()
        updatePreviewFromTime()
    end)
end
local function stopPlay()
    if not Editor.playing then return end
    Editor.playing = false
    if playConnection then playConnection:Disconnect(); playConnection=nil end
end

local function capturePoseTableFromRig()
    if not Editor.rig then return nil end
    local root = Editor.rig.PrimaryPart or Editor.rig:FindFirstChildWhichIsA("BasePart")
    local rootC = root and root.CFrame or CFrame.new()
    local t = {}
    for _,part in ipairs(Editor.skeleton) do
        if part and part:IsA("BasePart") then
            t[part.Name] = { CFrame = cframeToTable(rootC:ToObjectSpace(part.CFrame)) }
        end
    end
    return t
end
local function setKeyframeAt(frameIndex)
    frameIndex = math.max(0,math.floor(frameIndex))
    Editor.frames[frameIndex] = capturePoseTableFromRig()
    renderKeyframesUI()
end
local function deleteKeyframeAt(frameIndex)
    Editor.frames[frameIndex] = nil
    if Editor.selectedKeyframe==frameIndex then Editor.selectedKeyframe=nil end
    renderKeyframesUI()
end

-- UI WIRING
btnPlay.MouseButton1Click:Connect(function() startPlay() end)
btnStop.MouseButton1Click:Connect(function() stopPlay() end)
btnAddKF.MouseButton1Click:Connect(function()
    local frameIndex = math.floor(Editor.currentTime*Editor.fps+0.5)
    setKeyframeAt(frameIndex)
end)
btnDeleteKF.MouseButton1Click:Connect(function()
    local fi = math.floor(Editor.currentTime*Editor.fps+0.5)
    deleteKeyframeAt(fi)
end)

timelineBar.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        local absX = input.Position.X - timelineBar.AbsolutePosition.X
        local frame = absX / PIXELS_PER_FRAME
        Editor.currentTime = frame / Editor.fps
        updatePlayheadVisual()
        updatePreviewFromTime()
    end
end)

btnExportJSON.MouseButton1Click:Connect(function()
    local data = {
        frames = Editor.frames,
        fps = Editor.fps,
        timelineLength = Editor.timelineLength,
    }
    local json = HttpService:JSONEncode(data)
    pcall(function() setclipboard(json) end)
    btnExportJSON.Text = "Copiado!"
    wait(1)
    btnExportJSON.Text = "Exportar JSON"
end)

-- Exportar como script Lua (pronto pra ModuleScript)
local function exportAnimAsModule(animTable)
    local str = "return " .. HttpService:JSONEncode(animTable)
    str = str:gsub('"%[(%d+)%]"', '[%1]') -- ["0"] => [0]
    str = "-- POOK ANIMATION MODULE\n" .. str
    setclipboard(str)
    print("Script exportado para clipboarseen = {}
    for partName,ldata in pairs(leftData) do
        local rdata = rightData[partName] or ldata
        local ca = tableToCFrame(ldata.CFrame)
        local cb = tableToCFrame(rdata.CFrame)
        local lerp = ca:Lerp(cb, t)
        result[partName] = { CFrame = cframeToTable(lerp) }
        seen[partName] = true
    end
    for partName,rdata in pairs(rightData) do
        if not seen[partName] then
            result[partName] = { CFrame = rdata.CFrame }
        end
    end
    return result
end

local function applyFrameToModel(model, frameData)
    if not model or not frameData then return end
    local root = model.PrimaryPart or model:FindFirstChildWhichIsA("BasePart")
    if root then
        local rootC = root.CFrame
        for partName, data in pairs(frameData) do
            local p = model:FindFirstChild(partName, true)
            if p and p:IsA("BasePart") then
                local rel = tableToCFrame(data.CFrame)
                p.CFrame = rootC * rel
            end
        end
    else
        for partName, data in pairs(frameData) do
            local p = model:FindFirstChild(partName, true)
            if p and p:IsA("BasePart") then
                p.CFrame = tableToCFrame(data.CFrame)
            end
        end
    end
end

local function renderKeyframesUI()
    for _,ch in pairs(timelineBar:GetChildren()) do
        if ch:IsA("ImageButton") or (ch:IsA("Frame") and ch.Name:sub(1,3)=="KF_") then ch:Destroy() end
    end
    for frameIndex,_ in pairs(Editor.frames) do
        local x = frameIndex * PIXELS_PER_FRAME
        local marker = new("ImageButton", {
            Parent=timelineBar,
            Name="KF_"..tostring(frameIndex),
            Size=UDim2.fromOffset(8,18),
            Position=UDim2.new(0,x,0,2),
            BackgroundTransparency=1,
            AutoButtonColor=true
        })
    end
end

local function updatePlayheadVisual()
    local frameFloat = Editor.currentTime * Editor.fps
    local x = frameFloat * PIXELS_PER_FRAME
    playhead.Position = UDim2.new(0, x, 0, 0)
    lblFrame.Text = ("Frame: %.1f"):format(frameFloat)
end

local function updatePreviewFromTime()
    local frameFloat = Editor.currentTime * Editor.fps
    local evaluated = evaluateAtFrameFloat(frameFloat)
    if evaluated and Editor.preview then
        applyFrameToModel(Editor.preview, evaluated)
    end
end

local playConnection
local function startPlay()
    if Editor.playing then return end
    Editor.playing = true
    local playStart = tick()
    local playStartFrame = Editor.currentTime * Editor.fps
    playConnection = RunService.RenderStepped:Connect(function(dt)
        local elapsed = tick()-playStart
        local frame = playStartFrame+elapsed*Editor.fps
        if frame > Editor.timelineLength then
            frame = frame % Editor.timelineLength
            playStart = tick()
            playStartFrame = frame
        end
        Editor.currentTime = frame/Editor.fps
        updatePlayheadVisual()
        updatePreviewFromTime()
    end)
end
local function stopPlay()
    if not Editor.playing then return end
    Editor.playing = false
    if playConnection then playConnection:Disconnect(); playConnection=nil end
end

local function capturePoseTableFromRig()
    if not Editor.rig then return nil end
    local root = Editor.rig.PrimaryPart or Editor.rig:FindFirstChildWhichIsA("BasePart")
    local rootC = root and root.CFrame or CFrame.new()
    local t = {}
    for _,part in ipairs(Editor.skeleton) do
        if part and part:IsA("BasePart") then
            t[part.Name] = { CFrame = cframeToTable(rootC:ToObjectSpace(part.CFrame)) }
        end
    end
    return t
end
local function setKeyframeAt(frameIndex)
    frameIndex = math.max(0,math.floor(frameIndex))
    Editor.frames[frameIndex] = capturePoseTableFromRig()
    renderKeyframesUI()
end
local function deleteKeyframeAt(frameIndex)
    Editor.frames[frameIndex] = nil
    if Editor.selectedKeyframe==frameIndex then Editor.selectedKeyframe=nil end
    renderKeyframesUI()
end

btnPlay.MouseButton1Click:Connect(function() startPlay() end)
btnStop.MouseButton1Click:Connect(function() stopPlay() end)
btnAddKF.MouseButton1Click:Connect(function()
    local frameIndex = math.floor(Editor.currentTime*Editor.fps+0.5)
    setKeyframeAt(frameIndex)
end)
btnDeleteKF.MouseButton1Click:Connect(function()
    local fi = math.floor(Editor.currentTime*Editor.fps+0.5)
    deleteKeyframeAt(fi)
end)

timelineBar.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        local absX = input.Position.X - timelineBar.AbsolutePosition.X
        local frame = absX / PIXELS_PER_FRAME
        Editor.currentTime = frame / Editor.fps
        updatePlayheadVisual()
        updatePreviewFromTime()
    end
end)

btnExport.MouseButton1Click:Connect(function()
    local data = {
        frames = Editor.frames,
        fps = Editor.fps,
        timelineLength = Editor.timelineLength,
    }
    local json = HttpService:JSONEncode(data)
    pcall(function() setclipboard(json) end)
    btnExport.Text = "Copiado!"
    wait(1)
    btnExport.Text = "Exportar JSON"
end)
btnImport.MouseButton1Click:Connect(function()
    local ok, data = pcall(function() return HttpService:JSONDecode(importBox.Text) end)
    if ok then
        Editor.frames = data.frames or {}
        Editor.fps = data.fps or DEFAULT_FPS
        Editor.timelineLength = data.timelineLength or DEFAULT_TIMELINE_LENGTH
        renderKeyframesUI()
        btnImport.Text = "Importado!"
    else
        btnImport.Text = "Falha!"
    end
    wait(1)
    btnImport.Text = "Importar JSON"
end)

-- Detect Dummy no workspace
local function onDummyPresent(dummy)
    Editor.rig = dummy
    local parts = {}
    for _,d in pairs(dummy:GetDescendants()) do
        if d:IsA("BasePart") then table.insert(parts, d) end
    end
    Editor.skeleton = parts
    buildHierarchy()
    buildPreviewClone(dummy)
    renderKeyframesUI()
end
local function onDummyRemoved()
    Editor.rig = nil
    Editor.skeleton = {}
    clearHierarchy()
    if Editor.preview then Editor.preview:Destroy(); Editor.preview = nil end
end
local lastDummy = nil
local function checkDummy()
    local d = Workspace:FindFirstChild("Dummy")
    if d and d ~= lastDummy then
        lastDummy = d
        onDummyPresent(d)
    elseif not d and lastDummy then
        lastDummy = nil
        onDummyRemoved()
    end
end
checkDummy()
Workspace.ChildAdded:Connect(function(child) if child.Name=="Dummy" and child:IsA("Model") then checkDummy() end end)
Workspace.ChildRemoved:Connect(function(child) if child.Name=="Dummy" then checkDummy() end end)

renderKeyframesUI()
print("[Pook Animation Editor v0.5.2] Pronto! Compacto, sem erros, executor-friendly.")seen = {}
    for partName,ldata in pairs(leftData) do
        local rdata = rightData[partName] or ldata
        local ca = tableToCFrame(ldata.CFrame)
        local cb = tableToCFrame(rdata.CFrame)
        local lerp = ca:Lerp(cb, t)
        result[partName] = { CFrame = cframeToTable(lerp) }
        seen[partName] = true
    end
    for partName,rdata in pairs(rightData) do
        if not seen[partName] then
            result[partName] = { CFrame = rdata.CFrame }
        end
    end
    return result
end

local function applyFrameToModel(model, frameData)
    if not model or not frameData then return end
    local root = model.PrimaryPart or model:FindFirstChildWhichIsA("BasePart")
    if root then
        local rootC = root.CFrame
        for partName, data in pairs(frameData) do
            local p = model:FindFirstChild(partName, true)
            if p and p:IsA("BasePart") then
                local rel = tableToCFrame(data.CFrame)
                p.CFrame = rootC * rel
            end
        end
    else
        for partName, data in pairs(frameData) do
            local p = model:FindFirstChild(partName, true)
            if p and p:IsA("BasePart") then
                p.CFrame = tableToCFrame(data.CFrame)
            end
        end
    end
end

local function renderKeyframesUI()
    for _,ch in pairs(timelineBar:GetChildren()) do
        if ch:IsA("ImageButton") or (ch:IsA("Frame") and ch.Name:sub(1,3)=="KF_") then ch:Destroy() end
    end
    for frameIndex,_ in pairs(Editor.frames) do
        local x = frameIndex * PIXELS_PER_FRAME
        local marker = new("ImageButton", {
            Parent=timelineBar,
            Name="KF_"..tostring(frameIndex),
            Size=UDim2.fromOffset(8,18),
            Position=UDim2.new(0,x,0,2),
            BackgroundTransparency=1,
            AutoButtonColor=true
        })
    end
end

local function updatePlayheadVisual()
    local frameFloat = Editor.currentTime * Editor.fps
    local x = frameFloat * PIXELS_PER_FRAME
    playhead.Position = UDim2.new(0, x, 0, 0)
    lblFrame.Text = ("Frame: %.1f"):format(frameFloat)
end

local function updatePreviewFromTime()
    local frameFloat = Editor.currentTime * Editor.fps
    local evaluated = evaluateAtFrameFloat(frameFloat)
    if evaluated and Editor.preview then
        applyFrameToModel(Editor.preview, evaluated)
    end
end

local playConnection
local function startPlay()
    if Editor.playing then return end
    Editor.playing = true
    local playStart = tick()
    local playStartFrame = Editor.currentTime * Editor.fps
    playConnection = RunService.RenderStepped:Connect(function(dt)
        local elapsed = tick()-playStart
        local frame = playStartFrame+elapsed*Editor.fps
        if frame > Editor.timelineLength then
            frame = frame % Editor.timelineLength
            playStart = tick()
            playStartFrame = frame
        end
        Editor.currentTime = frame/Editor.fps
        updatePlayheadVisual()
        updatePreviewFromTime()
    end)
end
local function stopPlay()
    if not Editor.playing then return end
    Editor.playing = false
    if playConnection then playConnection:Disconnect(); playConnection=nil end
end

local function capturePoseTableFromRig()
    if not Editor.rig then return nil end
    local root = Editor.rig.PrimaryPart or Editor.rig:FindFirstChildWhichIsA("BasePart")
    local rootC = root and root.CFrame or CFrame.new()
    local t = {}
    for _,part in ipairs(Editor.skeleton) do
        if part and part:IsA("BasePart") then
            t[part.Name] = { CFrame = cframeToTable(rootC:ToObjectSpace(part.CFrame)) }
        end
    end
    return t
end
local function setKeyframeAt(frameIndex)
    frameIndex = math.max(0,math.floor(frameIndex))
    Editor.frames[frameIndex] = capturePoseTableFromRig()
    renderKeyframesUI()
end
local function deleteKeyframeAt(frameIndex)
    Editor.frames[frameIndex] = nil
    if Editor.selectedKeyframe==frameIndex then Editor.selectedKeyframe=nil end
    renderKeyframesUI()
end

btnPlay.MouseButton1Click:Connect(function() startPlay() end)
btnStop.MouseButton1Click:Connect(function() stopPlay() end)
btnAddKF.MouseButton1Click:Connect(function()
    local frameIndex = math.floor(Editor.currentTime*Editor.fps+0.5)
    setKeyframeAt(frameIndex)
end)
btnDeleteKF.MouseButton1Click:Connect(function()
    local fi = math.floor(Editor.currentTime*Editor.fps+0.5)
    deleteKeyframeAt(fi)
end)

timelineBar.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        local absX = input.Position.X - timelineBar.AbsolutePosition.X
        local frame = absX / PIXELS_PER_FRAME
        Editor.currentTime = frame / Editor.fps
        updatePlayheadVisual()
        updatePreviewFromTime()
    end
end)

btnExport.MouseButton1Click:Connect(function()
    local data = {
        frames = Editor.frames,
        fps = Editor.fps,
        timelineLength = Editor.timelineLength,
    }
    local json = HttpService:JSONEncode(data)
    pcall(function() setclipboard(json) end)
    btnExport.Text = "Copiado!"
    wait(1)
    btnExport.Text = "Exportar JSON"
end)
btnImport.MouseButton1Click:Connect(function()
    local ok, data = pcall(function() return HttpService:JSONDecode(importBox.Text) end)
    if ok then
        Editor.frames = data.frames or {}
        Editor.fps = data.fps or DEFAULT_FPS
        Editor.timelineLength = data.timelineLength or DEFAULT_TIMELINE_LENGTH
        renderKeyframesUI()
        btnImport.Text = "Importado!"
    else
        btnImport.Text = "Falha!"
    end
    wait(1)
    btnImport.Text = "Importar JSON"
end)

-- Detect Dummy no workspace
local function onDummyPresent(dummy)
    Editor.rig = dummy
    local parts = {}
    for _,d in pairs(dummy:GetDescendants()) do
        if d:IsA("BasePart") then table.insert(parts, d) end
    end
    Editor.skeleton = parts
    buildHierarchy()
    buildPreviewClone(dummy)
    renderKeyframesUI()
end
local function onDummyRemoved()
    Editor.rig = nil
    Editor.skeleton = {}
    clearHierarchy()
    if Editor.preview then Editor.preview:Destroy(); Editor.preview = nil end
end
local lastDummy = nil
local function checkDummy()
    local d = Workspace:FindFirstChild("Dummy")
    if d and d ~= lastDummy then
        lastDummy = d
        onDummyPresent(d)
    elseif not d and lastDummy then
        lastDummy = nil
        onDummyRemoved()
    end
end
checkDummy()
Workspace.ChildAdded:Connect(function(child) if child.Name=="Dummy" and child:IsA("Model") then checkDummy() end end)
Workspace.ChildRemoved:Connect(function(child) if child.Name=="Dummy" then checkDummy() end end)

renderKeyframesUI()
print("[Pook Animation Editor v0.5.2] Pronto! Compacto, sem erros, executor-friendly.")   rig = nil,
    skeleton = {},
    preview = nil,
    frames = {},
    currentTime = 0,
    playing = false,
    fps = DEFAULT_FPS,
    timelineLength = DEFAULT_TIMELINE_LENGTH,
    modeReplace = false,
    selectedKeyframe = nil,
    draggingPlayhead = false,
    onion = 1, -- onion skinning frames
    easeMode = "Linear", -- Linear, Quad, Cubic, Slerp
    copiedFrame = nil
}

local function cframeToTable(cf)
    local a,b,c,d,e,f,g,h,i,j,k,l = cf:components()
    return {a,b,c,d,e,f,g,h,i,j,k,l}
end
local function tableToCFrame(tbl)
    return CFrame.new(unpack(tbl))
end
local function slerpCF(a, b, t)
    return a:Lerp(b, t)
end

-- Hierarquia e Preview
local function clearHierarchy()
    for _,v in pairs(hierarchyList:GetChildren()) do
        if v:IsA("TextButton") or v:IsA("TextLabel") then v:Destroy() end
    end
end
local function buildHierarchy()
    clearHierarchy()
    for i,part in ipairs(Editor.skeleton) do
        local btn = new("TextButton", {
            Parent=hierarchyList,
            Size=UDim2.new(1, -8, 0, 28),
            BackgroundColor3=Color3.fromRGB(44,44,46),
            TextColor3=Color3.fromRGB(230,230,230),
            Font=Enum.Font.SourceSans,
            TextSize=14,
            Text=part.Name
        })
        btn.MouseButton1Click:Connect(function()
            for _,c in pairs(inspector:GetChildren()) do if c:IsA("TextLabel") or c:IsA("TextButton") then c:Destroy() end end
            new("TextLabel", {Parent=inspector, Size=UDim2.new(1,0,0,26), BackgroundTransparency=1, Text="Selecionado: "..part.Name, TextColor3=Color3.fromRGB(220,220,220), Font=Enum.Font.SourceSans, TextSize=16})
            new("TextLabel", {Parent=inspector, Size=UDim2.new(1,0,0,20), BackgroundTransparency=1, Text="Pos: "..tostring(part.Position), TextColor3=Color3.fromRGB(200,200,200), Font=Enum.Font.SourceSans, TextSize=14})
        end)
    end
end
local function buildPreviewClone(dummy)
    if Editor.preview and Editor.preview.Parent then
        Editor.preview:Destroy()
        Editor.preview = nil
    end
    if not dummy then return end
    local clone = dummy:Clone()
    clone.Name = "PreviewDummy"
    for _,d in pairs(clone:GetDescendants()) do
        if d:IsA("Script") or d:IsA("LocalScript") then d:Destroy() end
    end
    clone.Parent = viewport
    Editor.preview = clone
end

local function easeTime(t, mode)
    if mode=="Linear" then return t
    elseif mode=="Quad" then return t*t
    elseif mode=="Cubic" then return t*t*t
    elseif mode=="Slerp" then return t
    else return t end
end
local function evaluateAtFrameFloat(frameFloat)
    if frameFloat < 0 then frameFloat = 0 end
    local keys = {}
    for k,_ in pairs(Editor.frames) do table.insert(keys,k) end
    table.sort(keys)
    if #keys==0 then return nil end
    local left,right
    for i,k in ipairs(keys) do
        if k <= frameFloat then left = k end
        if k > frameFloat then right = k; break end
    end
    if not left then left = keys[1] end
    if not right then right = keys[#keys] end
    if left==right or frameFloat==left then
        return Editor.frames[left]
    end
    local t = (frameFloat-left)/(right-left)
    t = easeTime(t, Editor.easeMode)
    local leftData = Editor.frames[left] or {}
    local rightData = Editor.frames[right] or {}
    local result = {}
    local seen = {}
    for partName,ldata in pairs(leftData) do
        local rdata = rightData[partName] or ldata
        local ca = tableToCFrame(ldata.CFrame)
        local cb = tableToCFrame(rdata.CFrame)
        local lerp = slerpCF(ca, cb, t)
        result[partName] = { CFrame = cframeToTable(lerp) }
        seen[partName] = true
    end
    for partName,rdata in pairs(rightData) do
        if not seen[partName] then
            result[partName] = { CFrame = rdata.CFrame }
        end
    end
    return result
end

local function applyFrameToModel(model, frameData)
    if not model or not frameData then return end
    local root = model.PrimaryPart or model:FindFirstChildWhichIsA("BasePart")
    if root then
        local rootC = root.CFrame
        for partName, data in pairs(frameData) do
            local p = model:FindFirstChild(partName, true)
            if p and p:IsA("BasePart") then
                local rel = tableToCFrame(data.CFrame)
                p.CFrame = rootC * rel
            end
        end
    else
        for partName, data in pairs(frameData) do
            local p = model:FindFirstChild(partName, true)
            if p and p:IsA("BasePart") then
                p.CFrame = tableToCFrame(data.CFrame)
            end
        end
    end
end

local function renderOnionSkinning()
    for _,c in pairs(viewport:GetChildren()) do
        if c:IsA("Model") and c.Name:match("^Onion_") then c:Destroy() end
    end
    if not Editor.preview then return end
    for i=-Editor.onion, Editor.onion do
        if i~=0 then
            local frameIdx = math.floor(Editor.currentTime*Editor.fps+0.5)+i
            local data = Editor.frames[frameIdx]
            if data then
                local ghost = Editor.preview:Clone()
                ghost.Name = "Onion_"..i
                for _,p in pairs(ghost:GetDescendants()) do
                    if p:IsA("BasePart") then
                        p.Transparency = 0.7
                        p.Color = i<0 and Color3.fromRGB(0,140,255) or Color3.fromRGB(255,120,0)
                    end
                end
                ghost.Parent = viewport
                applyFrameToModel(ghost, data)
            end
        end
    end
end

local dragKF=nil
local dragKFOrig=nil
local dragStartPos=nil

local function renderKeyframesUI()
    for _,ch in pairs(timelineBar:GetChildren()) do
        if ch:IsA("ImageButton") or (ch:IsA("Frame") and ch.Name:sub(1,3)=="KF_") then ch:Destroy() end
    end
    for frameIndex,_ in pairs(Editor.frames) do
        local x = frameIndex * PIXELS_PER_FRAME
        local marker = new("ImageButton", {
            Parent=timelineBar,
            Name="KF_"..tostring(frameIndex),
            Size=UDim2.fromOffset(12,38),
            Position=UDim2.new(0,x,0,0),
            BackgroundTransparency=1,
            AutoButtonColor=true
        })
        local inner = new("Frame", {
            Parent=marker,
            Size=UDim2.new(1,0,1,0),
            BackgroundColor3=(Editor.selectedKeyframe==frameIndex and Color3.fromRGB(120,200,255) or Color3.fromRGB(220,130,70)),
            BorderSizePixel=0
        })
        marker.MouseButton1Down:Connect(function()
            dragKF = marker
            dragKFOrig = frameIndex
            dragStartPos = UserInputService:GetMouseLocation().X
        end)
        marker.MouseButton1Up:Connect(function()
            dragKF = nil
            dragKFOrig = nil
            dragStartPos = nil
        end)
        marker.MouseButton2Click:Connect(function()
            Editor.frames[frameIndex+1] = Editor.frames[frameIndex]
            renderKeyframesUI()
        end)
        marker.MouseButton1Click:Connect(function()
            if Editor.modeReplace then
                if Editor.rig then
                    local root = Editor.rig.PrimaryPart or Editor.rig:FindFirstChildWhichIsA("BasePart")
                    local rootC = root and root.CFrame or CFrame.new()
                    local newTable = {}
                    for _,part in ipairs(Editor.skeleton) do
                        if part and part:IsA("BasePart") then
                            newTable[part.Name] = { CFrame = cframeToTable(rootC:ToObjectSpace(part.CFrame)) }
                        end
                    end
                    Editor.frames[frameIndex] = newTable
                    Editor.modeReplace = false
                    btnReplaceMode.Text = "Modo: Normal"
                    renderKeyframesUI()
                    if Editor.preview then applyFrameToModel(Editor.preview, Editor.frames[frameIndex]) end
                    return
                end
            end
            Editor.selectedKeyframe = frameIndex
            Editor.currentTime = frameIndex / Editor.fps
            updatePlayheadVisual()
            local data = Editor.frames[frameIndex]
            if data and Editor.preview then
                applyFrameToModel(Editor.preview, data)
            end
            renderOnionSkinning()
            for _,ch in pairs(timelineBar:GetChildren()) do
                if ch:IsA("ImageButton") then
                    ch:FindFirstChildOfClass("Frame").BackgroundColor3 = Color3.fromRGB(220,130,70)
                end
            end
            if marker:FindFirstChildOfClass("Frame") then
                marker:FindFirstChildOfClass("Frame").BackgroundColor3 = Color3.fromRGB(120,200,255)
            end
        end)
    end
end

UserInputService.InputChanged:Connect(function(input)
    if dragKF and dragKFOrig and dragStartPos then
        if input.UserInputType==Enum.UserInputType.MouseMovement then
            local delta = UserInputService:GetMouseLocation().X-dragStartPos
            local framesDelta = math.floor(delta/PIXELS_PER_FRAME+0.5)
            if framesDelta~=0 then
                local newIndex = math.max(0,dragKFOrig+framesDelta)
                if not Editor.frames[newIndex] then
                    Editor.frames[newIndex] = Editor.frames[dragKFOrig]
                    Editor.frames[dragKFOrig] = nil
                    Editor.selectedKeyframe = newIndex
                    renderKeyframesUI()
                    dragKFOrig = newIndex
                    dragStartPos = UserInputService:GetMouseLocation().X
                end
            end
        end
    end
end)

local function updatePlayheadVisual()
    local frameFloat = Editor.currentTime * Editor.fps
    local x = frameFloat * PIXELS_PER_FRAME
    playhead.Position = UDim2.new(0, x-1, 0, -10*UI_SCALE)
    lblFrame.Text = ("Frame: %.1f"):format(frameFloat)
end

local function updatePreviewFromTime()
    local frameFloat = Editor.currentTime * Editor.fps
    local evaluated = evaluateAtFrameFloat(frameFloat)
    if evaluated and Editor.preview then
        applyFrameToModel(Editor.preview, evaluated)
    end
    renderOnionSkinning()
end

local playConnection
local function startPlay()
    if Editor.playing then return end
    Editor.playing = true
    local playStart = tick()
    local playStartFrame = Editor.currentTime * Editor.fps
    playConnection = RunService.RenderStepped:Connect(function(dt)
        local elapsed = tick()-playStart
        local frame = playStartFrame+elapsed*Editor.fps
        if frame > Editor.timelineLength then
            frame = frame % Editor.timelineLength
            playStart = tick()
            playStartFrame = frame
        end
        Editor.currentTime = frame/Editor.fps
        updatePlayheadVisual()
        updatePreviewFromTime()
    end)
end
local function stopPlay()
    if not Editor.playing then return end
    Editor.playing = false
    if playConnection then playConnection:Disconnect(); playConnection=nil end
end

local function capturePoseTableFromRig()
    if not Editor.rig then return nil end
    local root = Editor.rig.PrimaryPart or Editor.rig:FindFirstChildWhichIsA("BasePart")
    local rootC = root and root.CFrame or CFrame.new()
    local t = {}
    for _,part in ipairs(Editor.skeleton) do
        if part and part:IsA("BasePart") then
            t[part.Name] = { CFrame = cframeToTable(rootC:ToObjectSpace(part.CFrame)) }
        end
    end
    return t
end
local function setKeyframeAt(frameIndex)
    frameIndex = math.max(0,math.floor(frameIndex))
    Editor.frames[frameIndex] = capturePoseTableFromRig()
    renderKeyframesUI()
end
local function deleteKeyframeAt(frameIndex)
    Editor.frames[frameIndex] = nil
    if Editor.selectedKeyframe==frameIndex then Editor.selectedKeyframe=nil end
    renderKeyframesUI()
end

btnPlay.MouseButton1Click:Connect(function() startPlay() end)
btnStop.MouseButton1Click:Connect(function() stopPlay() end)
btnAddKF.MouseButton1Click:Connect(function()
    local frameIndex = math.floor(Editor.currentTime*Editor.fps+0.5)
    setKeyframeAt(frameIndex)
end)
btnReplaceMode.MouseButton1Click:Connect(function()
    Editor.modeReplace = not Editor.modeReplace
    btnReplaceMode.Text = Editor.modeReplace and "Modo: Substituir (clique KF)" or "Modo: Normal"
end)
btnDeleteKF.MouseButton1Click:Connect(function()
    if Editor.selectedKeyframe then
        deleteKeyframeAt(Editor.selectedKeyframe)
        Editor.selectedKeyframe=nil
    else
        local fi = math.floor(Editor.currentTime*Editor.fps+0.5)
        deleteKeyframeAt(fi)
    end
end)
btnDuplicateKF.MouseButton1Click:Connect(function()
    if Editor.selectedKeyframe then
        local nextIdx = Editor.selectedKeyframe+1
        Editor.frames[nextIdx]=Editor.frames[Editor.selectedKeyframe]
        Editor.selectedKeyframe=nextIdx
        renderKeyframesUI()
    end
end)
btnEase.MouseButton1Click:Connect(function()
    local modes = {"Linear","Quad","Cubic","Slerp"}
    local i = 1
    for idx,m in ipairs(modes) do if m==Editor.easeMode then i=idx end end
    i = i%#modes+1
    Editor.easeMode = modes[i]
    btnEase.Text = "Ease: "..Editor.easeMode
end)

btnExport.MouseButton1Click:Connect(function()
    local data = {
        name = Editor.name,
        frames = Editor.frames,
        fps = Editor.fps,
        timelineLength = Editor.timelineLength,
        easeMode = Editor.easeMode
    }
    local json = HttpService:JSONEncode(data)
    pcall(function() setclipboard(json) end)
    btnExport.Text = "Exportado!"
    wait(1.2)
    btnExport.Text = "Exportar JSON"
end)

btnImport.MouseButton1Click:Connect(function()
    local json = importBox.Text
    local ok, data = pcall(function() return HttpService:JSONDecode(json) end)
    if ok then
        Editor.name = data.name or Editor.name
        Editor.frames = data.frames or {}
        Editor.fps = data.fps or DEFAULT_FPS
        Editor.timelineLength = data.timelineLength or DEFAULT_TIMELINE_LENGTH
        Editor.easeMode = data.easeMode or "Linear"
        btnEase.Text = "Ease: "..Editor.easeMode
        renderKeyframesUI()
        btnImport.Text = "Importado!"
        wait(1.2)
        btnImport.Text = "Importar JSON"
    else
        btnImport.Text = "Falha!"
        wait(1)
        btnImport.Text = "Importar JSON"
    end
end)

btnRename.MouseButton1Click:Connect(function()
    if nameBox.Text and #nameBox.Text>0 then
        Editor.name = nameBox.Text
        btnRename.Text = "Renomeado!"
        wait(1)
        btnRename.Text = "Renomear Animação"
    end
end)

UserInputService.InputBegan:Connect(function(input, processed)
    if processed then return end
    if input.UserInputType == Enum.UserInputType.Keyboard then
        if input.KeyCode == Enum.KeyCode.K then
            local fi = math.floor(Editor.currentTime*Editor.fps+0.5)
            setKeyframeAt(fi)
        elseif input.KeyCode == Enum.KeyCode.L then
            if Editor.selectedKeyframe then deleteKeyframeAt(Editor.selectedKeyframe); Editor.selectedKeyframe=nil
            else local fi = math.floor(Editor.currentTime*Editor.fps+0.5); deleteKeyframeAt(fi) end
        elseif input.KeyCode == Enum.KeyCode.LeftControl or input.KeyCode == Enum.KeyCode.RightControl then
            UserInputService.InputBegan:Connect(function(key)
                if key.KeyCode==Enum.KeyCode.C then
                    if Editor.selectedKeyframe and Editor.frames[Editor.selectedKeyframe] then
                        Editor.copiedFrame = Editor.frames[Editor.selectedKeyframe]
                    end
                elseif key.KeyCode==Enum.KeyCode.V then
                    local fi = math.floor(Editor.currentTime*Editor.fps+0.5)
                    if Editor.copiedFrame then
                        Editor.frames[fi]=Editor.copiedFrame
                        renderKeyframesUI()
                    end
                end
            end)
        end
    end
end)

timelineCanvas.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        local absX = input.Position.X - timelineCanvas.AbsolutePosition.X
        local frame = absX / PIXELS_PER_FRAME
        Editor.currentTime = frame / Editor.fps
        updatePlayheadVisual()
        updatePreviewFromTime()
    end
end)

RunService.RenderStepped:Connect(function()
    if not Editor.playing then
        updatePlayheadVisual()
        updatePreviewFromTime()
    end
end)

local function onDummyPresent(dummy)
    Editor.rig = dummy
    local parts = {}
    for _,d in pairs(dummy:GetDescendants()) do
        if d:IsA("BasePart") then table.insert(parts, d) end
    end
    Editor.skeleton = parts
    buildHierarchy()
    buildPreviewClone(dummy)
    renderKeyframesUI()
end
local function onDummyRemoved()
    Editor.rig = nil
    Editor.skeleton = {}
    clearHierarchy()
    if Editor.preview then Editor.preview:Destroy(); Editor.preview = nil end
end

local lastDummy = nil
local function checkDummy()
    local d = Workspace:FindFirstChild("Dummy")
    if d and d ~= lastDummy then
        lastDummy = d
        onDummyPresent(d)
    elseif not d and lastDummy then
        lastDummy = nil
        onDummyRemoved()
    end
end
checkDummy()
Workspace.ChildAdded:Connect(function(child) if child.Name=="Dummy" and child:IsA("Model") then checkDummy() end end)
Workspace.ChildRemoved:Connect(function(child) if child.Name=="Dummy" then checkDummy() end end)

renderKeyframesUI()
print("[Pook Animation Editor v0.5.1] Pronto! Editor atualizado, funções melhoradas e bug do 'end' resolvido.")
