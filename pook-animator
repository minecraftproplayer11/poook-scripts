-- Pook Animation Editor v0.5.1 (Studio Lite, executor friendly)
-- Corrigido erro de 'end', arrumada timeline, funções melhoradas, robusto!

if game.CoreGui:FindFirstChild("PookAnimEditor") then
    game.CoreGui.PookAnimEditor:Destroy()
end

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")
local UserInputService = game:GetService("UserInputService")
local Workspace = workspace
local LOCAL_PLAYER = Players.LocalPlayer

local gui = Instance.new("ScreenGui")
gui.Name = "PookAnimEditor"
gui.Parent = game.CoreGui
gui.ResetOnSpawn = false

local VERSION = "Pook Animation Editor v0.5.1"
local DEFAULT_FPS = 30
local DEFAULT_TIMELINE_LENGTH = 120
local PIXELS_PER_FRAME = 6
local UI_SCALE = 1

local function new(class, props)
    local o = Instance.new(class)
    for k,v in pairs(props) do o[k]=v end
    return o
end

local function makeDraggable(frame, handle)
    handle = handle or frame
    local drag = false
    local dragStart, startPos
    handle.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            drag = true
            dragStart = input.Position
            startPos = frame.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    drag = false
                end
            end)
        end
    end)
    UserInputService.InputChanged:Connect(function(input)
        if drag and input.UserInputType==Enum.UserInputType.MouseMovement then
            local delta = input.Position-dragStart
            frame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset+delta.X, startPos.Y.Scale, startPos.Y.Offset+delta.Y)
        end
    end)
end

-- GUI Construction (simplificado, mas robusto)
local main = new("Frame", {
    Size=UDim2.fromOffset(1120*UI_SCALE, 700*UI_SCALE),
    Position=UDim2.new(0.06,0,0.13,0),
    BackgroundColor3=Color3.fromRGB(24,26,34),
    BorderSizePixel=0,
    Parent=gui,
    Name="MainFrame",
    Visible=true,
    Active=true,
    Draggable=true
})
makeDraggable(main, main)

local titleBar = new("Frame", {
    Size=UDim2.new(1,0,0,42*UI_SCALE),
    BackgroundColor3=Color3.fromRGB(18,20,26),
    Parent=main,
    Name="TitleBar"
})
makeDraggable(main, titleBar)

local title = new("TextLabel", {
    Size=UDim2.new(1,-160,1,0),
    Position=UDim2.new(0,14,0,0),
    BackgroundTransparency=1,
    Text=VERSION,
    Font=Enum.Font.SourceSansBold,
    TextSize=20*UI_SCALE,
    TextColor3=Color3.fromRGB(230,230,250),
    TextXAlignment=Enum.TextXAlignment.Left,
    Parent=titleBar
})

local closeBtn = new("TextButton", {
    Size=UDim2.fromOffset(108*UI_SCALE,32*UI_SCALE),
    Position=UDim2.new(1,-124*UI_SCALE,0,5*UI_SCALE),
    BackgroundColor3=Color3.fromRGB(52,52,60),
    Text="Fechar ✕",
    Font=Enum.Font.SourceSans,
    TextSize=17*UI_SCALE,
    TextColor3=Color3.fromRGB(230,100,100),
    Parent=titleBar,
    AutoButtonColor=true,
    ToolTip="Fechar o editor"
})
closeBtn.MouseButton1Click:Connect(function() gui:Destroy() end)

local leftPanel = new("Frame", {
    Size=UDim2.fromOffset(300*UI_SCALE, main.Size.Y.Offset-titleBar.Size.Y.Offset-0),
    Position=UDim2.new(0,0,0,titleBar.Size.Y.Offset),
    BackgroundColor3=Color3.fromRGB(36,38,45),
    Parent=main,
    Name="LeftPanel"
})
local leftTitle = new("TextLabel", {
    Size=UDim2.new(1,0,0,32),
    Position=UDim2.new(0,8,0,4),
    BackgroundTransparency=1,
    Text="Hierarquia (Dummy)",
    Font=Enum.Font.SourceSansBold,
    TextSize=17*UI_SCALE,
    TextColor3=Color3.fromRGB(220,220,220),
    TextXAlignment=Enum.TextXAlignment.Left,
    Parent=leftPanel
})
local hierarchyList = new("ScrollingFrame", {
    Name="HierarchyList",
    Size=UDim2.new(1,-16,1,-48),
    Position=UDim2.new(0,8,0,40),
    CanvasSize=UDim2.new(0,0,0,0),
    BackgroundTransparency=1,
    ScrollBarThickness=8,
    Parent=leftPanel
})
local hierarchyLayout = new("UIListLayout", {
    Parent=hierarchyList,
    SortOrder=Enum.SortOrder.LayoutOrder,
    Padding=UDim.new(0,6)
})

local centerPanel = new("Frame", {
    Size=UDim2.fromOffset(main.Size.X.Offset-leftPanel.Size.X.Offset-340*UI_SCALE, main.Size.Y.Offset-titleBar.Size.Y.Offset-130*UI_SCALE),
    Position=UDim2.new(0,leftPanel.Size.X.Offset,0,titleBar.Size.Y.Offset),
    BackgroundColor3=Color3.fromRGB(26,28,38),
    Parent=main,
    Name="CenterPanel"
})
local viewport = new("Frame", {
    Name="Viewport",
    Size=UDim2.new(1,0,1,-160*UI_SCALE),
    BackgroundColor3=Color3.fromRGB(18,18,18),
    Parent=centerPanel
})

-- Timeline
local timelinePanel = new("Frame", {
    Name="TimelinePanel",
    Size=UDim2.fromOffset(centerPanel.Size.X.Offset, 160*UI_SCALE),
    Position=UDim2.new(0,0,1,-160*UI_SCALE),
    BackgroundColor3=Color3.fromRGB(20,20,24),
    Parent=centerPanel
})
local timelineCanvas = new("Frame", {
    Name="TimelineCanvas",
    Size=UDim2.new(1,-20,1,-60),
    Position=UDim2.new(0,10,0,32),
    BackgroundTransparency=1,
    Parent=timelinePanel
})
local timelineBar = new("Frame", {
    Parent=timelineCanvas,
    Name="TimelineBar",
    Size=UDim2.new(1,0,0,38),
    BackgroundTransparency=1
})
local playhead = new("Frame", {
    Name="Playhead",
    Size=UDim2.fromOffset(2, 65*UI_SCALE),
    BackgroundColor3=Color3.fromRGB(255,80,80),
    Position=UDim2.new(0,0,0,-10*UI_SCALE),
    Parent=timelineCanvas,
    ZIndex=5
})

local controls = new("Frame", {
    Parent=timelinePanel,
    Size=UDim2.new(1,-20,0,36),
    Position=UDim2.new(0,10,1,-44),
    BackgroundTransparency=1
})
local btnPlay = new("TextButton", {
    Parent=controls,
    Size=UDim2.fromOffset(68*UI_SCALE,32*UI_SCALE),
    Position=UDim2.new(1,-80*UI_SCALE,0,2*UI_SCALE),
    Text="Play",
    ToolTip="Tocar animação (loop)"
})
local btnStop = new("TextButton", {
    Parent=controls,
    Size=UDim2.fromOffset(68*UI_SCALE,32*UI_SCALE),
    Position=UDim2.new(1,-158*UI_SCALE,0,2*UI_SCALE),
    Text="Stop",
    ToolTip="Parar animação"
})
local btnAddKF = new("TextButton", {
    Parent=controls,
    Size=UDim2.fromOffset(140*UI_SCALE,32*UI_SCALE),
    Position=UDim2.new(0,8,0,2*UI_SCALE),
    Text="Adicionar KF (K)",
    ToolTip="Adiciona keyframe no frame atual"
})
local btnReplaceMode = new("TextButton", {
    Parent=controls,
    Size=UDim2.fromOffset(120*UI_SCALE,32*UI_SCALE),
    Position=UDim2.new(0,154*UI_SCALE,0,2*UI_SCALE),
    Text="Modo: Normal",
    ToolTip="Modo substituir keyframe"
})
local btnDeleteKF = new("TextButton", {
    Parent=controls,
    Size=UDim2.fromOffset(140*UI_SCALE,32*UI_SCALE),
    Position=UDim2.new(0,286*UI_SCALE,0,2*UI_SCALE),
    Text="Excluir KF (L)",
    ToolTip="Remove keyframe do frame atual"
})
local btnDuplicateKF = new("TextButton", {
    Parent=controls,
    Size=UDim2.fromOffset(130*UI_SCALE,32*UI_SCALE),
    Position=UDim2.new(0,430*UI_SCALE,0,2*UI_SCALE),
    Text="Duplicar KF",
    ToolTip="Duplica keyframe selecionado"
})
local btnEase = new("TextButton", {
    Parent=controls,
    Size=UDim2.fromOffset(120*UI_SCALE,32*UI_SCALE),
    Position=UDim2.new(0,572*UI_SCALE,0,2*UI_SCALE),
    Text="Ease: Linear",
    ToolTip="Tipo de interpolação (clique para mudar)"
})
local lblFrame = new("TextLabel", {
    Parent=controls,
    Size=UDim2.fromOffset(260*UI_SCALE,32*UI_SCALE),
    Position=UDim2.new(0,702*UI_SCALE,0,2*UI_SCALE),
    Text="Frame: 0",
    BackgroundTransparency=1,
    TextColor3=Color3.fromRGB(220,220,220),
    TextXAlignment=Enum.TextXAlignment.Left
})

local rightPanel = new("Frame", {
    Name="RightPanel",
    Size=UDim2.fromOffset(340*UI_SCALE, main.Size.Y.Offset-titleBar.Size.Y.Offset-0),
    Position=UDim2.new(1,-340*UI_SCALE,0,titleBar.Size.Y.Offset),
    AnchorPoint=Vector2.new(1,0),
    BackgroundColor3=Color3.fromRGB(36,38,45),
    Parent=main
})
local rightTitle = new("TextLabel", {
    Parent=rightPanel,
    Size=UDim2.new(1,0,0,32),
    BackgroundTransparency=1,
    Text="Inspector / Exportar",
    Font=Enum.Font.SourceSansBold,
    TextSize=17*UI_SCALE,
    TextColor3=Color3.fromRGB(220,220,220),
    TextXAlignment=Enum.TextXAlignment.Left,
    Position=UDim2.new(0,8,0,4)
})
local inspector = new("ScrollingFrame", {
    Parent=rightPanel,
    Size=UDim2.new(1,-18,1,-74),
    Position=UDim2.new(0,9,0,38),
    BackgroundTransparency=1,
    ScrollBarThickness=8
})
local inspectorLayout = new("UIListLayout", {
    Parent=inspector,
    SortOrder=Enum.SortOrder.LayoutOrder,
    Padding=UDim.new(0,6)
})
local btnExport = new("TextButton", {
    Parent=rightPanel,
    Size=UDim2.fromOffset(120*UI_SCALE,32*UI_SCALE),
    Position=UDim2.new(0,16,1,-50*UI_SCALE),
    Text="Exportar JSON",
    ToolTip="Exporta animação para clipboard (JSON)"
})
local btnImport = new("TextButton", {
    Parent=rightPanel,
    Size=UDim2.fromOffset(120*UI_SCALE,32*UI_SCALE),
    Position=UDim2.new(0,152,1,-50*UI_SCALE),
    Text="Importar JSON",
    ToolTip="Importa animação de JSON"
})
local importBox = new("TextBox", {
    Parent=rightPanel,
    Size=UDim2.new(1,-28,0,28),
    Position=UDim2.new(0,14,1,-84),
    PlaceholderText="Cole o JSON aqui para importar",
    Font=Enum.Font.Code,
    BackgroundColor3=Color3.fromRGB(44,44,48),
    TextColor3=Color3.fromRGB(200,230,200),
    TextSize=14,
    ClearTextOnFocus=false
})
local btnRename = new("TextButton", {
    Parent=rightPanel,
    Size=UDim2.fromOffset(150*UI_SCALE,32*UI_SCALE),
    Position=UDim2.new(1,-166,1,-50*UI_SCALE),
    Text="Renomear Animação",
    ToolTip="Renomeia animação"
})
local nameBox = new("TextBox", {
    Parent=rightPanel,
    Size=UDim2.new(1,-28,0,28),
    Position=UDim2.new(0,14,1,-120),
    PlaceholderText="Nome da animação",
    Font=Enum.Font.Code,
    BackgroundColor3=Color3.fromRGB(44,44,48),
    TextColor3=Color3.fromRGB(240,230,180),
    TextSize=14,
    ClearTextOnFocus=false
})

-- ESTADO DO EDITOR
local Editor = {
    name = "Anim_"..tostring(math.floor(tick())),
    rig = nil,
    skeleton = {},
    preview = nil,
    frames = {},
    currentTime = 0,
    playing = false,
    fps = DEFAULT_FPS,
    timelineLength = DEFAULT_TIMELINE_LENGTH,
    modeReplace = false,
    selectedKeyframe = nil,
    draggingPlayhead = false,
    onion = 1, -- onion skinning frames
    easeMode = "Linear", -- Linear, Quad, Cubic, Slerp
    copiedFrame = nil
}

local function cframeToTable(cf)
    local a,b,c,d,e,f,g,h,i,j,k,l = cf:components()
    return {a,b,c,d,e,f,g,h,i,j,k,l}
end
local function tableToCFrame(tbl)
    return CFrame.new(unpack(tbl))
end
local function slerpCF(a, b, t)
    return a:Lerp(b, t)
end

-- Hierarquia e Preview
local function clearHierarchy()
    for _,v in pairs(hierarchyList:GetChildren()) do
        if v:IsA("TextButton") or v:IsA("TextLabel") then v:Destroy() end
    end
end
local function buildHierarchy()
    clearHierarchy()
    for i,part in ipairs(Editor.skeleton) do
        local btn = new("TextButton", {
            Parent=hierarchyList,
            Size=UDim2.new(1, -8, 0, 28),
            BackgroundColor3=Color3.fromRGB(44,44,46),
            TextColor3=Color3.fromRGB(230,230,230),
            Font=Enum.Font.SourceSans,
            TextSize=14,
            Text=part.Name
        })
        btn.MouseButton1Click:Connect(function()
            for _,c in pairs(inspector:GetChildren()) do if c:IsA("TextLabel") or c:IsA("TextButton") then c:Destroy() end end
            new("TextLabel", {Parent=inspector, Size=UDim2.new(1,0,0,26), BackgroundTransparency=1, Text="Selecionado: "..part.Name, TextColor3=Color3.fromRGB(220,220,220), Font=Enum.Font.SourceSans, TextSize=16})
            new("TextLabel", {Parent=inspector, Size=UDim2.new(1,0,0,20), BackgroundTransparency=1, Text="Pos: "..tostring(part.Position), TextColor3=Color3.fromRGB(200,200,200), Font=Enum.Font.SourceSans, TextSize=14})
        end)
    end
end
local function buildPreviewClone(dummy)
    if Editor.preview and Editor.preview.Parent then
        Editor.preview:Destroy()
        Editor.preview = nil
    end
    if not dummy then return end
    local clone = dummy:Clone()
    clone.Name = "PreviewDummy"
    for _,d in pairs(clone:GetDescendants()) do
        if d:IsA("Script") or d:IsA("LocalScript") then d:Destroy() end
    end
    clone.Parent = viewport
    Editor.preview = clone
end

local function easeTime(t, mode)
    if mode=="Linear" then return t
    elseif mode=="Quad" then return t*t
    elseif mode=="Cubic" then return t*t*t
    elseif mode=="Slerp" then return t
    else return t end
end
local function evaluateAtFrameFloat(frameFloat)
    if frameFloat < 0 then frameFloat = 0 end
    local keys = {}
    for k,_ in pairs(Editor.frames) do table.insert(keys,k) end
    table.sort(keys)
    if #keys==0 then return nil end
    local left,right
    for i,k in ipairs(keys) do
        if k <= frameFloat then left = k end
        if k > frameFloat then right = k; break end
    end
    if not left then left = keys[1] end
    if not right then right = keys[#keys] end
    if left==right or frameFloat==left then
        return Editor.frames[left]
    end
    local t = (frameFloat-left)/(right-left)
    t = easeTime(t, Editor.easeMode)
    local leftData = Editor.frames[left] or {}
    local rightData = Editor.frames[right] or {}
    local result = {}
    local seen = {}
    for partName,ldata in pairs(leftData) do
        local rdata = rightData[partName] or ldata
        local ca = tableToCFrame(ldata.CFrame)
        local cb = tableToCFrame(rdata.CFrame)
        local lerp = slerpCF(ca, cb, t)
        result[partName] = { CFrame = cframeToTable(lerp) }
        seen[partName] = true
    end
    for partName,rdata in pairs(rightData) do
        if not seen[partName] then
            result[partName] = { CFrame = rdata.CFrame }
        end
    end
    return result
end

local function applyFrameToModel(model, frameData)
    if not model or not frameData then return end
    local root = model.PrimaryPart or model:FindFirstChildWhichIsA("BasePart")
    if root then
        local rootC = root.CFrame
        for partName, data in pairs(frameData) do
            local p = model:FindFirstChild(partName, true)
            if p and p:IsA("BasePart") then
                local rel = tableToCFrame(data.CFrame)
                p.CFrame = rootC * rel
            end
        end
    else
        for partName, data in pairs(frameData) do
            local p = model:FindFirstChild(partName, true)
            if p and p:IsA("BasePart") then
                p.CFrame = tableToCFrame(data.CFrame)
            end
        end
    end
end

local function renderOnionSkinning()
    for _,c in pairs(viewport:GetChildren()) do
        if c:IsA("Model") and c.Name:match("^Onion_") then c:Destroy() end
    end
    if not Editor.preview then return end
    for i=-Editor.onion, Editor.onion do
        if i~=0 then
            local frameIdx = math.floor(Editor.currentTime*Editor.fps+0.5)+i
            local data = Editor.frames[frameIdx]
            if data then
                local ghost = Editor.preview:Clone()
                ghost.Name = "Onion_"..i
                for _,p in pairs(ghost:GetDescendants()) do
                    if p:IsA("BasePart") then
                        p.Transparency = 0.7
                        p.Color = i<0 and Color3.fromRGB(0,140,255) or Color3.fromRGB(255,120,0)
                    end
                end
                ghost.Parent = viewport
                applyFrameToModel(ghost, data)
            end
        end
    end
end

local dragKF=nil
local dragKFOrig=nil
local dragStartPos=nil

local function renderKeyframesUI()
    for _,ch in pairs(timelineBar:GetChildren()) do
        if ch:IsA("ImageButton") or (ch:IsA("Frame") and ch.Name:sub(1,3)=="KF_") then ch:Destroy() end
    end
    for frameIndex,_ in pairs(Editor.frames) do
        local x = frameIndex * PIXELS_PER_FRAME
        local marker = new("ImageButton", {
            Parent=timelineBar,
            Name="KF_"..tostring(frameIndex),
            Size=UDim2.fromOffset(12,38),
            Position=UDim2.new(0,x,0,0),
            BackgroundTransparency=1,
            AutoButtonColor=true
        })
        local inner = new("Frame", {
            Parent=marker,
            Size=UDim2.new(1,0,1,0),
            BackgroundColor3=(Editor.selectedKeyframe==frameIndex and Color3.fromRGB(120,200,255) or Color3.fromRGB(220,130,70)),
            BorderSizePixel=0
        })
        marker.MouseButton1Down:Connect(function()
            dragKF = marker
            dragKFOrig = frameIndex
            dragStartPos = UserInputService:GetMouseLocation().X
        end)
        marker.MouseButton1Up:Connect(function()
            dragKF = nil
            dragKFOrig = nil
            dragStartPos = nil
        end)
        marker.MouseButton2Click:Connect(function()
            Editor.frames[frameIndex+1] = Editor.frames[frameIndex]
            renderKeyframesUI()
        end)
        marker.MouseButton1Click:Connect(function()
            if Editor.modeReplace then
                if Editor.rig then
                    local root = Editor.rig.PrimaryPart or Editor.rig:FindFirstChildWhichIsA("BasePart")
                    local rootC = root and root.CFrame or CFrame.new()
                    local newTable = {}
                    for _,part in ipairs(Editor.skeleton) do
                        if part and part:IsA("BasePart") then
                            newTable[part.Name] = { CFrame = cframeToTable(rootC:ToObjectSpace(part.CFrame)) }
                        end
                    end
                    Editor.frames[frameIndex] = newTable
                    Editor.modeReplace = false
                    btnReplaceMode.Text = "Modo: Normal"
                    renderKeyframesUI()
                    if Editor.preview then applyFrameToModel(Editor.preview, Editor.frames[frameIndex]) end
                    return
                end
            end
            Editor.selectedKeyframe = frameIndex
            Editor.currentTime = frameIndex / Editor.fps
            updatePlayheadVisual()
            local data = Editor.frames[frameIndex]
            if data and Editor.preview then
                applyFrameToModel(Editor.preview, data)
            end
            renderOnionSkinning()
            for _,ch in pairs(timelineBar:GetChildren()) do
                if ch:IsA("ImageButton") then
                    ch:FindFirstChildOfClass("Frame").BackgroundColor3 = Color3.fromRGB(220,130,70)
                end
            end
            if marker:FindFirstChildOfClass("Frame") then
                marker:FindFirstChildOfClass("Frame").BackgroundColor3 = Color3.fromRGB(120,200,255)
            end
        end)
    end
end

UserInputService.InputChanged:Connect(function(input)
    if dragKF and dragKFOrig and dragStartPos then
        if input.UserInputType==Enum.UserInputType.MouseMovement then
            local delta = UserInputService:GetMouseLocation().X-dragStartPos
            local framesDelta = math.floor(delta/PIXELS_PER_FRAME+0.5)
            if framesDelta~=0 then
                local newIndex = math.max(0,dragKFOrig+framesDelta)
                if not Editor.frames[newIndex] then
                    Editor.frames[newIndex] = Editor.frames[dragKFOrig]
                    Editor.frames[dragKFOrig] = nil
                    Editor.selectedKeyframe = newIndex
                    renderKeyframesUI()
                    dragKFOrig = newIndex
                    dragStartPos = UserInputService:GetMouseLocation().X
                end
            end
        end
    end
end)

local function updatePlayheadVisual()
    local frameFloat = Editor.currentTime * Editor.fps
    local x = frameFloat * PIXELS_PER_FRAME
    playhead.Position = UDim2.new(0, x-1, 0, -10*UI_SCALE)
    lblFrame.Text = ("Frame: %.1f"):format(frameFloat)
end

local function updatePreviewFromTime()
    local frameFloat = Editor.currentTime * Editor.fps
    local evaluated = evaluateAtFrameFloat(frameFloat)
    if evaluated and Editor.preview then
        applyFrameToModel(Editor.preview, evaluated)
    end
    renderOnionSkinning()
end

local playConnection
local function startPlay()
    if Editor.playing then return end
    Editor.playing = true
    local playStart = tick()
    local playStartFrame = Editor.currentTime * Editor.fps
    playConnection = RunService.RenderStepped:Connect(function(dt)
        local elapsed = tick()-playStart
        local frame = playStartFrame+elapsed*Editor.fps
        if frame > Editor.timelineLength then
            frame = frame % Editor.timelineLength
            playStart = tick()
            playStartFrame = frame
        end
        Editor.currentTime = frame/Editor.fps
        updatePlayheadVisual()
        updatePreviewFromTime()
    end)
end
local function stopPlay()
    if not Editor.playing then return end
    Editor.playing = false
    if playConnection then playConnection:Disconnect(); playConnection=nil end
end

local function capturePoseTableFromRig()
    if not Editor.rig then return nil end
    local root = Editor.rig.PrimaryPart or Editor.rig:FindFirstChildWhichIsA("BasePart")
    local rootC = root and root.CFrame or CFrame.new()
    local t = {}
    for _,part in ipairs(Editor.skeleton) do
        if part and part:IsA("BasePart") then
            t[part.Name] = { CFrame = cframeToTable(rootC:ToObjectSpace(part.CFrame)) }
        end
    end
    return t
end
local function setKeyframeAt(frameIndex)
    frameIndex = math.max(0,math.floor(frameIndex))
    Editor.frames[frameIndex] = capturePoseTableFromRig()
    renderKeyframesUI()
end
local function deleteKeyframeAt(frameIndex)
    Editor.frames[frameIndex] = nil
    if Editor.selectedKeyframe==frameIndex then Editor.selectedKeyframe=nil end
    renderKeyframesUI()
end

btnPlay.MouseButton1Click:Connect(function() startPlay() end)
btnStop.MouseButton1Click:Connect(function() stopPlay() end)
btnAddKF.MouseButton1Click:Connect(function()
    local frameIndex = math.floor(Editor.currentTime*Editor.fps+0.5)
    setKeyframeAt(frameIndex)
end)
btnReplaceMode.MouseButton1Click:Connect(function()
    Editor.modeReplace = not Editor.modeReplace
    btnReplaceMode.Text = Editor.modeReplace and "Modo: Substituir (clique KF)" or "Modo: Normal"
end)
btnDeleteKF.MouseButton1Click:Connect(function()
    if Editor.selectedKeyframe then
        deleteKeyframeAt(Editor.selectedKeyframe)
        Editor.selectedKeyframe=nil
    else
        local fi = math.floor(Editor.currentTime*Editor.fps+0.5)
        deleteKeyframeAt(fi)
    end
end)
btnDuplicateKF.MouseButton1Click:Connect(function()
    if Editor.selectedKeyframe then
        local nextIdx = Editor.selectedKeyframe+1
        Editor.frames[nextIdx]=Editor.frames[Editor.selectedKeyframe]
        Editor.selectedKeyframe=nextIdx
        renderKeyframesUI()
    end
end)
btnEase.MouseButton1Click:Connect(function()
    local modes = {"Linear","Quad","Cubic","Slerp"}
    local i = 1
    for idx,m in ipairs(modes) do if m==Editor.easeMode then i=idx end end
    i = i%#modes+1
    Editor.easeMode = modes[i]
    btnEase.Text = "Ease: "..Editor.easeMode
end)

btnExport.MouseButton1Click:Connect(function()
    local data = {
        name = Editor.name,
        frames = Editor.frames,
        fps = Editor.fps,
        timelineLength = Editor.timelineLength,
        easeMode = Editor.easeMode
    }
    local json = HttpService:JSONEncode(data)
    pcall(function() setclipboard(json) end)
    btnExport.Text = "Exportado!"
    wait(1.2)
    btnExport.Text = "Exportar JSON"
end)

btnImport.MouseButton1Click:Connect(function()
    local json = importBox.Text
    local ok, data = pcall(function() return HttpService:JSONDecode(json) end)
    if ok then
        Editor.name = data.name or Editor.name
        Editor.frames = data.frames or {}
        Editor.fps = data.fps or DEFAULT_FPS
        Editor.timelineLength = data.timelineLength or DEFAULT_TIMELINE_LENGTH
        Editor.easeMode = data.easeMode or "Linear"
        btnEase.Text = "Ease: "..Editor.easeMode
        renderKeyframesUI()
        btnImport.Text = "Importado!"
        wait(1.2)
        btnImport.Text = "Importar JSON"
    else
        btnImport.Text = "Falha!"
        wait(1)
        btnImport.Text = "Importar JSON"
    end
end)

btnRename.MouseButton1Click:Connect(function()
    if nameBox.Text and #nameBox.Text>0 then
        Editor.name = nameBox.Text
        btnRename.Text = "Renomeado!"
        wait(1)
        btnRename.Text = "Renomear Animação"
    end
end)

UserInputService.InputBegan:Connect(function(input, processed)
    if processed then return end
    if input.UserInputType == Enum.UserInputType.Keyboard then
        if input.KeyCode == Enum.KeyCode.K then
            local fi = math.floor(Editor.currentTime*Editor.fps+0.5)
            setKeyframeAt(fi)
        elseif input.KeyCode == Enum.KeyCode.L then
            if Editor.selectedKeyframe then deleteKeyframeAt(Editor.selectedKeyframe); Editor.selectedKeyframe=nil
            else local fi = math.floor(Editor.currentTime*Editor.fps+0.5); deleteKeyframeAt(fi) end
        elseif input.KeyCode == Enum.KeyCode.LeftControl or input.KeyCode == Enum.KeyCode.RightControl then
            UserInputService.InputBegan:Connect(function(key)
                if key.KeyCode==Enum.KeyCode.C then
                    if Editor.selectedKeyframe and Editor.frames[Editor.selectedKeyframe] then
                        Editor.copiedFrame = Editor.frames[Editor.selectedKeyframe]
                    end
                elseif key.KeyCode==Enum.KeyCode.V then
                    local fi = math.floor(Editor.currentTime*Editor.fps+0.5)
                    if Editor.copiedFrame then
                        Editor.frames[fi]=Editor.copiedFrame
                        renderKeyframesUI()
                    end
                end
            end)
        end
    end
end)

timelineCanvas.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        local absX = input.Position.X - timelineCanvas.AbsolutePosition.X
        local frame = absX / PIXELS_PER_FRAME
        Editor.currentTime = frame / Editor.fps
        updatePlayheadVisual()
        updatePreviewFromTime()
    end
end)

RunService.RenderStepped:Connect(function()
    if not Editor.playing then
        updatePlayheadVisual()
        updatePreviewFromTime()
    end
end)

local function onDummyPresent(dummy)
    Editor.rig = dummy
    local parts = {}
    for _,d in pairs(dummy:GetDescendants()) do
        if d:IsA("BasePart") then table.insert(parts, d) end
    end
    Editor.skeleton = parts
    buildHierarchy()
    buildPreviewClone(dummy)
    renderKeyframesUI()
end
local function onDummyRemoved()
    Editor.rig = nil
    Editor.skeleton = {}
    clearHierarchy()
    if Editor.preview then Editor.preview:Destroy(); Editor.preview = nil end
end

local lastDummy = nil
local function checkDummy()
    local d = Workspace:FindFirstChild("Dummy")
    if d and d ~= lastDummy then
        lastDummy = d
        onDummyPresent(d)
    elseif not d and lastDummy then
        lastDummy = nil
        onDummyRemoved()
    end
end
checkDummy()
Workspace.ChildAdded:Connect(function(child) if child.Name=="Dummy" and child:IsA("Model") then checkDummy() end end)
Workspace.ChildRemoved:Connect(function(child) if child.Name=="Dummy" then checkDummy() end end)

renderKeyframesUI()
print("[Pook Animation Editor v0.5.1] Pronto! Editor atualizado, funções melhoradas e bug do 'end' resolvido.")
